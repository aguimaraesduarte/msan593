for(i in 1:length(vec)){
tryCatch(print(log(vec[i])),
error = function(x){
writeLines(paste("\nError\nCannot compute the log of string '", vec[i], "'\n", sep = ""))
},
warning = function(x){
writeLines(paste("\nWarning\nCannot compute log of negative number", vec[i], "\n"))
})
}
logVector(-1)
logVector(c(1,2,3))
logVector(c(1,-2,3))
logVector <- function(vec){
for(i in 1:length(vec)){
tryCatch(print("log of", vec[i], "is", log(vec[i])),
error = function(x){
writeLines(paste("\nError\nCannot compute the log of string '", vec[i], "'\n", sep = ""))
},
warning = function(x){
writeLines(paste("\nWarning\nCannot compute log of negative number", vec[i], "\n"))
})
}
logVector(c(1,-2,3))
logVector <- function(vec){
for(i in 1:length(vec)){
tryCatch(print(paste("log of", vec[i], "is", log(vec[i]))),
error = function(x){
writeLines(paste("\nError\nCannot compute the log of string '", vec[i], "'\n", sep = ""))
},
warning = function(x){
writeLines(paste("\nWarning\nCannot compute log of negative number", vec[i], "\n"))
})
}
logVector(c(1,-2,3))
logVector(c(1,-2,"a"))
logVector <- function(vec){
for(i in 1:length(vec)){
tryCatch(print(paste("log of", vec[i], "is", log(vec[i]))),
error = function(x){
writeLines(paste("Error\nCannot compute the log of string '", vec[i], "'\n", sep = ""))
},
warning = function(x){
writeLines(paste("Warning\nCannot compute log of negative number", vec[i], "\n"))
})
}
logVector(c(1,-2,"a"))
logVector(c(1,2,3))
logVector(c(1,-2,3))
logVector <- function(vec){
for(i in 1:length(vec)){
tryCatch(print(paste("log of", vec[i], "is", log(vec[i]))),
error = function(x){
writeLines(paste("Error\nCannot compute the log of string '", vec[i], "'", sep = ""))
},
warning = function(x){
writeLines(paste("Warning\nCannot compute log of negative number", vec[i]))
})
}
logVector(c(1,2,3))
logVector(c(1,-2,3))
logVector(c(1,-2,"a"))
logVector(0)
r0.618
r <- 0.618
re <- sqrt(1-r^2)
x <- rnorm(1000)
y <- x*r + rnorm(1000)*re
y[x<0] <- -y[x<0]
par(mar=rep(0,4))
plot(x, y, col=rgb(1,0,1), axes=F, asp=1)
x <- rnorm(100000)
y <- x*r + rnorm(1000)*re
y[x<0] <- -y[x<0]
plot(x, y, col=rgb(1,0,1), axes=F, asp=1)
x <- rnorm(10000)
y <- x*r + rnorm(1000)*re
y[x<0] <- -y[x<0]
plot(x, y, col=rgb(1,0,1), axes=F, asp=1)
myDataFrame <- data.frame(x = 1:3, y = -4:-6, z = LETTERS[1:3])
myDataFrame[[1]]
myDataFrame
myDataFrame[[1,]]
myDataFrame[1,]
order(c(NA,4,2,7,2,9))
order(c(NA,4,2,7,2,9), na.last = F)
order(c(NA,4,2,7,2,9), decreasing = T)
order(c(NA,4,2,7,2,9), decreasing = F)
?length
a=c()
length(a) <- 5
a
myFunc <- function(nReps, myScatterInput, myClusterNum){
## Define variables for the function
# seed
s = 1001
# number of rows and columns
n <- nrow(myScatterInput)
m <- ncol(myScatterInput)
# convert the data frame into a matrix
scatterMatrix <- as.matrix(x = myScatterInput)
bestRep_euclideanSum <- Inf
## Repeat nReps times
for(r in 1:nReps){
set.seed(s)
# randomly choose <myClusterNum> cluster points
clusterCenters <- scatterMatrix[sample(1:n, myClusterNum),]
newClusterCenters <- clusterCenters
# pre-allocate matrix with euclidean distances
distances <- matrix(NA, nrow = n, ncol = myClusterNum)
## Repeat up to <maxIter> times, or newClusterCenters == clusterCenters
iter <- 0
while(iter < maxIter){
# get Euclidean distance from each point to all clusters
for(i in 1:nrow(clusterCenters)){
distances[, i] <- apply(scatterMatrix, 1, function(x) sqrt(sum((x-clusterCenters[i,])^2)))
}
# assign each point to the cluster center closest to it
belongToCluster <- apply(distances, 1, function(x) which(x == min(x, na.rm = T))[1])
# update clusters
for(i in 1:myClusterNum){
newClusterCenters[i,] <- apply(as.matrix(scatterMatrix[belongToCluster == i,]), 2, mean)
}
# break condition (newClusterCenters == clusterCenters)
if(isTRUE(all.equal(newClusterCenters, clusterCenters))) break
# else update clusterCenters
clusterCenters <- newClusterCenters
iter <- iter + 1
}
## Compute sum of all Euclidean distances from each point to their cluster center
euclideanSum <- 0
for(i in 1:n){
euclideanSum <- euclideanSum + distances[i, belongToCluster[i]]
}
## Store information about this repetition if it's the best
if(euclideanSum < bestRep_euclideanSum){
bestRep <- r
bestRep_belongToCluster <- belongToCluster
bestRep_euclideanSum <- euclideanSum
}
s <- s + 1
}
## Print the best result
print(paste("The repetition for which we get the lowest sum of Euclidean distances is number ", bestRep,
", for which we get a value of ", round(bestRep_euclideanSum, 3), ".", sep=""))
## If m = 2, make a 2d scatter plot
if(m == 2){
plot(scatterMatrix, type = "p", col = bestRep_belongToCluster,
main = "Clustering result")
}
## If m == 3, make a 3d scatter plot
if(m == 3){
if(!"scatterplot3d" %in% rownames(installed.packages())){
install.packages("scatterplot3d", dependencies = T)
}
library(scatterplot3d)
scatterplot3d(scatterMatrix, color = bestRep_belongToCluster,
main = "Clustering result")
}
maxIter=1
df=data.frame(runif(100,0,1), runif(100,0,1), runif(100,0,1), runif(100,0,1))
myFunc(100, df, 3)
df2=df[c(1,2,3)]
df3=df[1:2]
df4=df[1]
myFunc(100, df2, 3)
myFunc(100, df3, 3)
myFunc(100, df4, 3)
myFunc <- function(nReps, myScatterInput, myClusterNum){
## Define variables for the function
# seed
s = 1001
# number of rows and columns
n <- nrow(myScatterInput)
m <- ncol(myScatterInput)
# convert the data frame into a matrix
scatterMatrix <- as.matrix(x = myScatterInput)
bestRep_euclideanSum <- Inf
## Repeat nReps times
for(r in 1:nReps){
set.seed(s)
# randomly choose <myClusterNum> cluster points
clusterCenters <- scatterMatrix[sample(1:n, myClusterNum),]
newClusterCenters <- clusterCenters
# pre-allocate matrix with euclidean distances
distances <- matrix(NA, nrow = n, ncol = myClusterNum)
## Repeat up to <maxIter> times, or newClusterCenters == clusterCenters
iter <- 0
while(iter < maxIter){
# get Euclidean distance from each point to all clusters
print(nrow(clusterCenters))
for(i in 1:nrow(clusterCenters)){
distances[, i] <- apply(scatterMatrix, 1, function(x) sqrt(sum((x-clusterCenters[i,])^2)))
}
# assign each point to the cluster center closest to it
belongToCluster <- apply(distances, 1, function(x) which(x == min(x, na.rm = T))[1])
# update clusters
for(i in 1:myClusterNum){
newClusterCenters[i,] <- apply(as.matrix(scatterMatrix[belongToCluster == i,]), 2, mean)
}
# break condition (newClusterCenters == clusterCenters)
if(isTRUE(all.equal(newClusterCenters, clusterCenters))) break
# else update clusterCenters
clusterCenters <- newClusterCenters
iter <- iter + 1
}
## Compute sum of all Euclidean distances from each point to their cluster center
euclideanSum <- 0
for(i in 1:n){
euclideanSum <- euclideanSum + distances[i, belongToCluster[i]]
}
## Store information about this repetition if it's the best
if(euclideanSum < bestRep_euclideanSum){
bestRep <- r
bestRep_belongToCluster <- belongToCluster
bestRep_euclideanSum <- euclideanSum
}
s <- s + 1
}
## Print the best result
print(paste("The repetition for which we get the lowest sum of Euclidean distances is number ", bestRep,
", for which we get a value of ", round(bestRep_euclideanSum, 3), ".", sep=""))
## If m = 2, make a 2d scatter plot
if(m == 2){
plot(scatterMatrix, type = "p", col = bestRep_belongToCluster,
main = "Clustering result")
}
## If m == 3, make a 3d scatter plot
if(m == 3){
if(!"scatterplot3d" %in% rownames(installed.packages())){
install.packages("scatterplot3d", dependencies = T)
}
library(scatterplot3d)
scatterplot3d(scatterMatrix, color = bestRep_belongToCluster,
main = "Clustering result")
}
myFunc(100, df4, 3)
myFunc <- function(nReps, myScatterInput, myClusterNum){
## Define variables for the function
# seed
s = 1001
# number of rows and columns
n <- nrow(myScatterInput)
m <- ncol(myScatterInput)
# convert the data frame into a matrix
scatterMatrix <- as.matrix(x = myScatterInput)
bestRep_euclideanSum <- Inf
## Repeat nReps times
for(r in 1:nReps){
set.seed(s)
# randomly choose <myClusterNum> cluster points
clusterCenters <- scatterMatrix[sample(1:n, myClusterNum),]
print clusterCenters
newClusterCenters <- clusterCenters
# pre-allocate matrix with euclidean distances
distances <- matrix(NA, nrow = n, ncol = myClusterNum)
## Repeat up to <maxIter> times, or newClusterCenters == clusterCenters
iter <- 0
while(iter < maxIter){
# get Euclidean distance from each point to all clusters
for(i in 1:nrow(clusterCenters)){
distances[, i] <- apply(scatterMatrix, 1, function(x) sqrt(sum((x-clusterCenters[i,])^2)))
}
# assign each point to the cluster center closest to it
belongToCluster <- apply(distances, 1, function(x) which(x == min(x, na.rm = T))[1])
# update clusters
for(i in 1:myClusterNum){
newClusterCenters[i,] <- apply(as.matrix(scatterMatrix[belongToCluster == i,]), 2, mean)
}
# break condition (newClusterCenters == clusterCenters)
if(isTRUE(all.equal(newClusterCenters, clusterCenters))) break
# else update clusterCenters
clusterCenters <- newClusterCenters
iter <- iter + 1
}
## Compute sum of all Euclidean distances from each point to their cluster center
euclideanSum <- 0
for(i in 1:n){
euclideanSum <- euclideanSum + distances[i, belongToCluster[i]]
}
## Store information about this repetition if it's the best
if(euclideanSum < bestRep_euclideanSum){
bestRep <- r
bestRep_belongToCluster <- belongToCluster
bestRep_euclideanSum <- euclideanSum
}
s <- s + 1
}
## Print the best result
print(paste("The repetition for which we get the lowest sum of Euclidean distances is number ", bestRep,
", for which we get a value of ", round(bestRep_euclideanSum, 3), ".", sep=""))
## If m = 2, make a 2d scatter plot
if(m == 2){
plot(scatterMatrix, type = "p", col = bestRep_belongToCluster,
main = "Clustering result")
}
## If m == 3, make a 3d scatter plot
if(m == 3){
if(!"scatterplot3d" %in% rownames(installed.packages())){
install.packages("scatterplot3d", dependencies = T)
}
library(scatterplot3d)
scatterplot3d(scatterMatrix, color = bestRep_belongToCluster,
main = "Clustering result")
}
myFunc <- function(nReps, myScatterInput, myClusterNum){
## Define variables for the function
# seed
s = 1001
# number of rows and columns
n <- nrow(myScatterInput)
m <- ncol(myScatterInput)
# convert the data frame into a matrix
scatterMatrix <- as.matrix(x = myScatterInput)
bestRep_euclideanSum <- Inf
## Repeat nReps times
for(r in 1:nReps){
set.seed(s)
# randomly choose <myClusterNum> cluster points
clusterCenters <- scatterMatrix[sample(1:n, myClusterNum),]
print(clusterCenters)
newClusterCenters <- clusterCenters
# pre-allocate matrix with euclidean distances
distances <- matrix(NA, nrow = n, ncol = myClusterNum)
## Repeat up to <maxIter> times, or newClusterCenters == clusterCenters
iter <- 0
while(iter < maxIter){
# get Euclidean distance from each point to all clusters
for(i in 1:nrow(clusterCenters)){
distances[, i] <- apply(scatterMatrix, 1, function(x) sqrt(sum((x-clusterCenters[i,])^2)))
}
# assign each point to the cluster center closest to it
belongToCluster <- apply(distances, 1, function(x) which(x == min(x, na.rm = T))[1])
# update clusters
for(i in 1:myClusterNum){
newClusterCenters[i,] <- apply(as.matrix(scatterMatrix[belongToCluster == i,]), 2, mean)
}
# break condition (newClusterCenters == clusterCenters)
if(isTRUE(all.equal(newClusterCenters, clusterCenters))) break
# else update clusterCenters
clusterCenters <- newClusterCenters
iter <- iter + 1
}
## Compute sum of all Euclidean distances from each point to their cluster center
euclideanSum <- 0
for(i in 1:n){
euclideanSum <- euclideanSum + distances[i, belongToCluster[i]]
}
## Store information about this repetition if it's the best
if(euclideanSum < bestRep_euclideanSum){
bestRep <- r
bestRep_belongToCluster <- belongToCluster
bestRep_euclideanSum <- euclideanSum
}
s <- s + 1
}
## Print the best result
print(paste("The repetition for which we get the lowest sum of Euclidean distances is number ", bestRep,
", for which we get a value of ", round(bestRep_euclideanSum, 3), ".", sep=""))
## If m = 2, make a 2d scatter plot
if(m == 2){
plot(scatterMatrix, type = "p", col = bestRep_belongToCluster,
main = "Clustering result")
}
## If m == 3, make a 3d scatter plot
if(m == 3){
if(!"scatterplot3d" %in% rownames(installed.packages())){
install.packages("scatterplot3d", dependencies = T)
}
library(scatterplot3d)
scatterplot3d(scatterMatrix, color = bestRep_belongToCluster,
main = "Clustering result")
}
myFunc(100, df4, 3)
myFunc <- function(nReps, myScatterInput, myClusterNum){
## Define variables for the function
# seed
s = 1001
# number of rows and columns
n <- nrow(myScatterInput)
m <- ncol(myScatterInput)
# convert the data frame into a matrix
scatterMatrix <- as.matrix(x = myScatterInput)
bestRep_euclideanSum <- Inf
## Repeat nReps times
for(r in 1:nReps){
set.seed(s)
# randomly choose <myClusterNum> cluster points
clusterCenters <- scatterMatrix[sample(1:n, myClusterNum), drop=F]
print(clusterCenters)
newClusterCenters <- clusterCenters
# pre-allocate matrix with euclidean distances
distances <- matrix(NA, nrow = n, ncol = myClusterNum)
## Repeat up to <maxIter> times, or newClusterCenters == clusterCenters
iter <- 0
while(iter < maxIter){
# get Euclidean distance from each point to all clusters
for(i in 1:nrow(clusterCenters)){
distances[, i] <- apply(scatterMatrix, 1, function(x) sqrt(sum((x-clusterCenters[i,])^2)))
}
# assign each point to the cluster center closest to it
belongToCluster <- apply(distances, 1, function(x) which(x == min(x, na.rm = T))[1])
# update clusters
for(i in 1:myClusterNum){
newClusterCenters[i,] <- apply(as.matrix(scatterMatrix[belongToCluster == i,]), 2, mean)
}
# break condition (newClusterCenters == clusterCenters)
if(isTRUE(all.equal(newClusterCenters, clusterCenters))) break
# else update clusterCenters
clusterCenters <- newClusterCenters
iter <- iter + 1
}
## Compute sum of all Euclidean distances from each point to their cluster center
euclideanSum <- 0
for(i in 1:n){
euclideanSum <- euclideanSum + distances[i, belongToCluster[i]]
}
## Store information about this repetition if it's the best
if(euclideanSum < bestRep_euclideanSum){
bestRep <- r
bestRep_belongToCluster <- belongToCluster
bestRep_euclideanSum <- euclideanSum
}
s <- s + 1
}
## Print the best result
print(paste("The repetition for which we get the lowest sum of Euclidean distances is number ", bestRep,
", for which we get a value of ", round(bestRep_euclideanSum, 3), ".", sep=""))
## If m = 2, make a 2d scatter plot
if(m == 2){
plot(scatterMatrix, type = "p", col = bestRep_belongToCluster,
main = "Clustering result")
}
## If m == 3, make a 3d scatter plot
if(m == 3){
if(!"scatterplot3d" %in% rownames(installed.packages())){
install.packages("scatterplot3d", dependencies = T)
}
library(scatterplot3d)
scatterplot3d(scatterMatrix, color = bestRep_belongToCluster,
main = "Clustering result")
}
myFunc(100, df4, 3)
myFunc <- function(nReps, myScatterInput, myClusterNum){
## Define variables for the function
# seed
s = 1001
# number of rows and columns
n <- nrow(myScatterInput)
m <- ncol(myScatterInput)
# convert the data frame into a matrix
scatterMatrix <- as.matrix(x = myScatterInput)
bestRep_euclideanSum <- Inf
## Repeat nReps times
for(r in 1:nReps){
set.seed(s)
# randomly choose <myClusterNum> cluster points
clusterCenters <- as.matrix(scatterMatrix[sample(1:n, myClusterNum),])
newClusterCenters <- clusterCenters
# pre-allocate matrix with euclidean distances
distances <- matrix(NA, nrow = n, ncol = myClusterNum)
## Repeat up to <maxIter> times, or newClusterCenters == clusterCenters
iter <- 0
while(iter < maxIter){
# get Euclidean distance from each point to all clusters
for(i in 1:nrow(clusterCenters)){
distances[, i] <- apply(scatterMatrix, 1, function(x) sqrt(sum((x-clusterCenters[i,])^2)))
}
# assign each point to the cluster center closest to it
belongToCluster <- apply(distances, 1, function(x) which(x == min(x, na.rm = T))[1])
# update clusters
for(i in 1:myClusterNum){
newClusterCenters[i,] <- apply(as.matrix(scatterMatrix[belongToCluster == i,]), 2, mean)
}
# break condition (newClusterCenters == clusterCenters)
if(isTRUE(all.equal(newClusterCenters, clusterCenters))) break
# else update clusterCenters
clusterCenters <- newClusterCenters
iter <- iter + 1
}
## Compute sum of all Euclidean distances from each point to their cluster center
euclideanSum <- 0
for(i in 1:n){
euclideanSum <- euclideanSum + distances[i, belongToCluster[i]]
}
## Store information about this repetition if it's the best
if(euclideanSum < bestRep_euclideanSum){
bestRep <- r
bestRep_belongToCluster <- belongToCluster
bestRep_euclideanSum <- euclideanSum
}
s <- s + 1
}
## Print the best result
print(paste("The repetition for which we get the lowest sum of Euclidean distances is number ", bestRep,
", for which we get a value of ", round(bestRep_euclideanSum, 3), ".", sep=""))
## If m = 2, make a 2d scatter plot
if(m == 2){
plot(scatterMatrix, type = "p", col = bestRep_belongToCluster,
main = "Clustering result")
}
## If m == 3, make a 3d scatter plot
if(m == 3){
if(!"scatterplot3d" %in% rownames(installed.packages())){
install.packages("scatterplot3d", dependencies = T)
}
library(scatterplot3d)
scatterplot3d(scatterMatrix, color = bestRep_belongToCluster,
main = "Clustering result")
}
myFunc(100, df4, 3)
setwd("~/Documents/msan593/HW3")
source('~/Documents/msan593/HW3/asn3_q1.R', echo=TRUE)

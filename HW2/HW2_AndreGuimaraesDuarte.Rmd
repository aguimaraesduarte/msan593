---
title: "MSAN 593 - Homework 2"
author: "Andre Guimaraes Duarte"
date: "July 24, 2016"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

<!-- Reset R session -->
`r rm(list=ls())`
`r cat("\014")`

# Question 1
## 1.1
### 1.1.1
```{r myRunifVec, fig.cap="Histogram of 10,000,000 random variables ~ U(4, 6)\\label{runifPop}", cache=T}
myRunifVec <- runif(10000000, 4, 6)
hist(myRunifVec,
     main = paste("Histogram of ", length(myRunifVec), "\n random variables ~ U(4, 6)",
                  sep = ""), xlab = "x", freq = F)
```

The histogram in figure \ref{runifPop} is the histogram of a $\sim U(4, 6)$ distribution with `r as.integer(length(myRunifVec))` random variables. 

### 1.1.2
```{r sampleUnif, fig.cap="Histogram of a sample of 100,000 random elements from a ~U(4, 6) distribution\\label{runifSample}", cache=T}
samples <- 100000
myRunifSample <- sample(myRunifVec, 100000)
hist(myRunifSample,
     main = paste("Histogram of ", length(myRunifSample),
                  "\n random variables sampled from a ~ U(4, 6)",
                  sep = ""), xlab = "x", freq = F)
```

The histogram in figure \ref{runifSample} is very similar to the population distribution \ref{runifPop}. Sampling elements from a uniform distribution maintains its original distribution.

### 1.1.3
Disclaimer: I first did this assignment in its entirety using `for` loops. My computer handled up to 1,000 samples fairly OK, but once the number of samples reached a few tens of thousands, it was unbearably slow to take the samples and means. I figured that `for` loops were not the way to go for this exercise, and did some research of some vectorized alternatives. I found that using the `apply` method was conveninent in this case, and indeed the results are much, **much** faster.

First, I define a data frame called `myRunifDataFrame` that has 30 columns. Each column will have `100,000` rows of single random samples from the vector `myRunifVec`. To do 30 repetitions of sampling 100,000 random variables, I use the `replicate` method. This does not simply copy the results from one column to the other, but indeed each column will have a separate sample of 100,000 random variables from the original distribution. `replicate` replicates the function, in this case `sample`.

Then, I define a second data frame, called `myRunifMeans` that contains the means of two, five, ten, and thirty elements from the original distribution. By using the `apply` method, I can define which columns (how many) of `myRunifDataFrame` to use in order to compute the mean. This takes only a couple of seconds to run, opposed to many minutes by using the previous method (`for` loops) and is much more efficient.

```{r runifDataFrame, cache=T}
myRunifDataFrame <- data.frame(replicate(30, sample(myRunifVec, 100000)))
myRunifMeans <- data.frame("Means2"= apply(myRunifDataFrame[,1:2], 1, mean),
                           "Means5"= apply(myRunifDataFrame[,1:5], 1, mean),
                           "Means10"= apply(myRunifDataFrame[,1:10], 1, mean),
                           "Means30"= apply(myRunifDataFrame[,1:30], 1, mean))
```

```{r runifMean2, fig.cap="Histogram of 100,000 random means of two elements from a ~U(4, 6) distribution\\label{runif2}", cache=T}
hist(myRunifMeans$Means2, main="Histogram of the average of two elements from a ~Unif(4, 6)",
     xlab="x", freq = F)
```

The histogram in figure \ref{runif2} is not similar to the population distribution shown in figure \ref{runifPop}. In fact, the distribution seems very triangular.

### 1.1.4
```{r runifMean5, fig.cap="Histogram of 100,000 random means of five elements from a ~U(4, 6) distribution\\label{runif5}", cache=T}
hist(myRunifMeans$Means5, main="Histogram of the average of five elements from a ~Unif(4, 6)",
     xlab="x", freq = F)
```

The histogram in figure \ref{runif5} is different from the population distribution in figure \ref{runifPop}. There are more observations around $5$, and less toward the tails. It is different than the previous histogram (figure \ref{runif2}): the distribution is less triangular.

### 1.1.5
```{r runifMean10, fig.cap="Histogram of 100,000 random means of ten elements from a ~U(4, 6) distribution\\label{runif10}", cache=T}
hist(myRunifMeans$Means10, main="Histogram of the average of ten elements from a ~Unif(4, 6)",
     xlab="x", freq = F)
```

The histogram in figure \ref{runif10} is different from the population distribution in figure \ref{runifPop}. This one is bell-shaped and seems to be symmetrical around the value $5$.

### 1.1.6
```{r runifMean30, fig.cap="Histogram of 100,000 random means of thirty elements from a ~U(4, 6) distribution\\label{runif30}", cache=T}
hist(myRunifMeans$Means30, main="Histogram of the average of thirty elements from a ~Unif(4, 6)",
     xlab="x", freq = F)
```

The histogram in figure \ref{runif30} is different from the population distribution in figure \ref{runifPop}. It looks a lot like a normal distribution centered around $5$.

***

<!-- Reset R session -->
`r rm(list=ls())`
`r cat("\014")`

## 1.2
### 1.2.1
```{r myRexpVec, fig.cap="Histogram of 10,000,000 random variables ~Exp(0.5)\\label{rexpPop}", cache=T}
myRexpVec <- rexp(10000000, 0.5)
hist(myRexpVec,
     main = paste("Histogram of ", length(myRexpVec), "\n random variables ~ Exp(0.5)",
                  sep = ""), xlab = "x", freq = F)
```

Figure \ref{rexpPop} shows the histogram of a $\sim Exp(0.5)$ distribution with `r as.integer(length(myRexpVec))` random variables.

### 1.2.2
```{r sampleExp, fig.cap="Histogram of 100,000 random elements from a ~Exp(0.5) distribution\\label{rexpSample}", cache=T}
myRexpSample <- sample(myRexpVec, 100000)
hist(myRexpSample,
     main = paste("Histogram of ", length(myRexpSample),
                  "\n random variables sampled from a ~ Exp(0.5)",
                  sep = ""), xlab = "x", freq = F)
```

The histogram in figure \ref{rexpSample} is very similar to the population distribution \ref{rexpPop}. Sampling elements from a negative exponential distribution maintains its original distribution.

### 1.2.3


```{r rexpDataFrame, cache=T}
myRexpDataFrame <- data.frame(replicate(30, sample(myRexpVec, 100000)))
myRexpMeans <- data.frame("Means2"= apply(myRexpDataFrame[,1:2], 1, mean),
                           "Means5"= apply(myRexpDataFrame[,1:5], 1, mean),
                           "Means10"= apply(myRexpDataFrame[,1:10], 1, mean),
                           "Means30"= apply(myRexpDataFrame[,1:30], 1, mean))
```

```{r rexpMean2, fig.cap="Histogram of 100,000 random means of two elements from a ~Exp(0.5) distribution\\label{rexp2}", cache=T}
hist(myRexpMeans$Means2, main="Histogram of the average of two elements from a ~Exp(0.5)",
     xlab="x", freq = F)
```

Figure \ref{rexp2} shows the histogram is slightly more skewed to the right than the population distribution in figure \ref{rexpPop}. In fact, this is a Gamma distribution with parameter $\alpha = 2*0.5 = 1$.

### 1.2.4
```{r rexpMean5, fig.cap="Histogram of 100,000 random means of five elements from a ~Exp(0.5) distribution\\label{rexp5}", cache=T}
hist(myRexpMeans$Means5, main="Histogram of the average of five elements from a ~Exp(0.5)",
     xlab="x", freq = F)
```

The histogram when we take the mean of five elements from the original population, shown in figure \ref{rexp5}, is very different from the histogram of the population distribution in figure \ref{rexpPop}. It looks like the values are slowly distributing themselves around $2$, but with a longer tail to the right.

### 1.2.5
```{r rexpMean10, fig.cap="Histogram of 100,000 random means of ten elements from a ~Exp(0.5) distribution\\label{rexp10}", cache=T}
hist(myRexpMeans$Means10, main="Histogram of the average of ten elements from a ~Exp(0.5)",
     xlab="x", freq = F)
```

By averaging ten elements, we can see in figure \ref{rexp10} that the distribution seems to be getting closer to a normal distribution centered around $2$. 

### 1.2.6
```{r rexpMean30, fig.cap="Histogram of 100,000 random means of thirty elements from a ~Exp(0.5) distribution\\label{rexp30}", cache=T}
hist(myRexpMeans$Means30, main="Histogram of the average of thirty elements from a ~Exp(0.5)",
     xlab="x", freq = F)
```

In figure \ref{rexp30}, we see the histogram when we take the average of 30 elements from the original negative exponential population shown in figure \ref{rexpPop}. The distribution is now very different, and looks like a normal distribution with mean $2$. The tail on the right is still slightly more spread than the one on the left.

***

<!-- Reset R session -->
`r rm(list=ls())`
`r cat("\014")`

## 1.3
### 1.3.1
```{r myBdist, fig.cap="Histogram of 5,000,000 random variables from a ~N(-3, 1) and 5,000,000 random variables from a ~N(3, 1)\\label{bdistPop}", cache=T}
myBdist <- c(rnorm(5000000, -3, 1), rnorm(5000000, 3, 1))
hist(myBdist, main="Bimodal histogram of ~N(-3, 1) and ~N(3, 1)", xlab="x", freq = F)
```

We can see from the histogram in figure \ref{bdistPop} that the distribution is bimodal. In fact, we have random variables from two distinct normal distributions, one centered around $-3$ and the other around $3$. Both variances are equal to $1$.

### 1.3.2


```{r bdistDataFrame, cache=T}
myBdistDataFrame <- data.frame(replicate(30, sample(myBdist, 100000)))
myBdistMeans <- data.frame("Means5"= apply(myBdistDataFrame[,1:5], 1, mean),
                           "Means10"= apply(myBdistDataFrame[,1:10], 1, mean),
                           "Means20"= apply(myBdistDataFrame[,1:20], 1, mean),
                           "Means30"= apply(myBdistDataFrame[,1:30], 1, mean))
```

```{r bdist5, fig.cap="Histogram of 100,000 random means of five elements from a ~N(-3, 1) and a ~N(3, 1) distributions\\label{bdist5}", cache=T}
hist(myBdistMeans$Means5, main="Histogram of the average of five elements
     from a ~N(-3, 1) and a ~N(3, 1)", xlab="x", freq = F)
```

We can gather from the histogram in image \ref{bdist5} that the bimodality seen in figure \ref{bdistPop} is lost. Indeed, this histogram has only one "bump", and has a lot of values between $-2$ and $2$.

### 1.3.3
```{r bdist10, fig.cap="Histogram of 100,000 random means of ten  elements from a ~N(-3, 1) and a ~N(3, 1) distributions\\label{bdist10}", cache=T}
hist(myBdistMeans$Means10, main="Histogram of the average of ten elements
     from a ~N(-3, 1) and a ~N(3, 1)", xlab="x", freq = F)
```

The histogram in figure \ref{bdist10} is similar to the previous one (figure \ref{bdist5}), but less spread out. It is starting to look like a normal distribution.

```{r bdist20, fig.cap="Histogram of 100,000 random means of twenty elements from a ~N(-3, 1) and a ~N(3, 1) distributions\\label{bdist20}", cache=T}
hist(myBdistMeans$Means20, main="Histogram of the average of twenty elements from
     a ~N(-3, 1) and a ~N(3, 1)", xlab="x", freq = F)
```

By averaging over 20 elements from the original pouplation, the histogram seen in figure \ref{bdist20} is looking a lot like a normal distribution centered around $0$. The spread of the distribution is becoming smaller the more elements we average.

```{r bdist30, fig.cap="Histogram of 100,000 random means of thirty elements from a ~N(-3, 1) and a ~N(3, 1) distributions\\label{bdist30}", cache=T}
hist(myBdistMeans$Means30, main="Histogram of the average of thirty elements from
     a ~N(-3, 1) and a ~N(3, 1)", xlab="x", freq = F)
```

The histogram in figure \ref{bdist30} does not look like the original population distribution in figure \ref{bdistPop}. In fact, the two modes that were present at first have completely disappeared. In its place, we seems to have a single standard normal distribution, centered around the average of the original two means: $\frac{-3 + 3}{2} = 0$.

### 1.3.4



***

<!-- Reset R session -->
`r rm(list=ls())`
`r cat("\014")`

# Question 2


```{r, cache=T}
myData <- read.csv("hw2.csv", header = T, stringsAsFactors = F)
names(myData)
str(myData, strict.width = "w")
```
number of rows = `r nrow(myData)`

number of cols = `r ncol(myData)`

```{r, cache=T}
# TODO: rename columns!
myData$Service.Contract..Service.Contract.Event..Using.Build.Partner. <- as.logical(myData$Service.Contract..Service.Contract.Event..Using.Build.Partner.)
myData$Opportunity..Service.Panel.Upgrade <- as.logical(myData$Opportunity..Service.Panel.Upgrade)
myData$Opportunity..Reroof.under.Array <- as.logical(myData$Opportunity..Reroof.under.Array)
myData$Opportunity..PE.Stamp.Required. <- as.logical(myData$Opportunity..PE.Stamp.Required.)

myData$Opportunity..HOA.[myData$Opportunity..HOA. == "0"]  <- "No"
myData$Opportunity..HOA.[myData$Opportunity..HOA. == "1"]  <- "Yes"
myData$Opportunity..HOA. <- factor(myData$Opportunity..HOA., levels = unique(myData$Opportunity..HOA.))

myData$Project.Status <- factor(myData$Project.Status, levels = unique(myData$Project.Status))

myData$Opportunity..Purchased.Thru[myData$Opportunity..Purchased.Thru == "Costco (Dept 44)"] <- "Costco"
myData$Opportunity..Purchased.Thru <- factor(myData$Opportunity..Purchased.Thru, levels = unique(myData$Opportunity..Purchased.Thru))
myData$Agreement.Type <- factor(myData$Agreement.Type, levels = unique(myData$Agreement.Type))
myData$Opportunity..Utility.Company <- factor(myData$Opportunity..Utility.Company, levels = unique(myData$Opportunity..Utility.Company))

#unique(myData$Install.Branch) # uniformize the data (STATE - City)
#unique(myData$Install.Branch) # uniformize the data (STATE - City)
#unique(myData$Install.Branch) # uniformize the data (regular expressions?)
```

